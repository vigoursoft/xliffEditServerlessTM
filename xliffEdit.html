<html>
<head>
<meta charset="UTF-8">
<title>XLiff Editor</title>
<style>

#header {
    position: fixed;
    top: 0px;
    height: 60px;
    width: 100%;
    background: lightblue;
}
#bod{ margin-top: 60px; height: 400px; overflow: auto; }
#tmx{ margin-top: 20px; height: 200px; overflow: auto;  background: rgba(255, 0, 0, 0.3); }
#note{ background-color: rgba(255, 0, 0, 0.3); }


table { font-family: arial, sans-serif; border-collapse: collapse;   width: 100%;}
td, th {  border: 1px solid #dddddd;  text-align: left;  padding: 2px;}
tr:nth-child(even) { background-color: #dddddd;}

#index { width: 3%; }
#xliff {width: 48%;}

</style>


<script>
/* The alpha version
by Hans
Copyright: whatever, use, modify, sell, trade, just say thank you
*/

var targetNodes=[];


var xmlDoc;
// keeping this global - might be a problem for large tmx docs
var tmxDoc;


var xliffContent;
var tmxContent;

// inside onload
 window.onload = function () {
 
 xliffContent = localStorage.xliff;
	if (xliffContent) {	
	    parseXliff();
	}
 
 // Check for the various File API support.
if (window.File && window.FileReader && window.FileList && window.Blob) {
 // alert("Browser supports the required apis");
} else {
  alert('The File APIs are not fully supported by your browser.');
}
 
  function readMultipleFiles(evt) {
    //Retrieve all the files from the FileList object
    var files = evt.target.files; 
    		
    if (files) {
        for (var i=0, f; f=files[i]; i++) {
	          var r = new FileReader();
            r.onload = (function(f) {
                return function(e) {
                       var mac = e.target.result;
					   
					   if ( (f.name).endsWith("xliff") ){
						 
						 localStorage.xliffName=f.name;
						 xliffContent=mac;
						 parseXliff();
						}
						else if ( (f.name).endsWith(".tmx") ){
						 tmxContent=mac;
						// alert(tmxContent);
						 parseTMX();
						}
					/*	
                    alert( "Got the file.n" 
                          +"name: " + f.name + "n"
                          +"type: " + f.type + "n"
                          +"size: " + f.size + " bytesn"
                          + "starts with: " + mac.substr(1, 10)
                    ); */ 
					
                };
            })(f);

            r.readAsText(f);
			//r.readAsDataURL(f);
        }   
    } else {
	      alert("Failed to load files"); 
    }
  }
  
  document.getElementById('fileinput').addEventListener('change', readMultipleFiles, false);
  
  
 }
 
 
 function parseXliff(){

 var tbl=document.getElementById("tableDiv");
 if (tbl !== null)
  tbl.innerHTML="";
  
 // localStorage.clear();
 
 parser = new DOMParser();
 xmlDoc = parser.parseFromString(xliffContent,"text/xml");
 //get all transunits
 var transunits= xmlDoc.getElementsByTagName("trans-unit");
 var source; var target; var text="start";
 var tchildren;
 
 targetNodes=[];
 
            var table = document.createElement('table');
            table.innerHTML = "";
            var thead = document.createElement('thead');
            table.appendChild(thead);
            var hrow = document.createElement('tr');
            thead.appendChild(hrow);
            var tbody = document.createElement('tbody');
            table.appendChild(tbody);
			var cell;
            var cellText;
 
 for (var i=0;i < transunits.length; i++ ){
      tchildren=transunits[i].children;
	  
      var hrow = document.createElement('tr');	  
         cell = document.createElement('td');	 
         cellText = document.createTextNode(i+1);
         cell.appendChild(cellText);
         hrow.appendChild(cell);
		 cell.setAttribute("id","index");
	  
	  
         cell = document.createElement('td');
         source=tchildren[0].innerHTML;		 
         cellText = document.createTextNode(source);
         cell.appendChild(cellText);
         hrow.appendChild(cell);
         cell.setAttribute("id","xliff");		 
		 
	     target=tchildren[1].innerHTML; 
		 targetNodes.push(tchildren[1]);
         cell = document.createElement('td');	 
		 
         cellText = document.createTextNode(target);
         cell.appendChild(cellText);
		 cell.setAttribute("contenteditable","true");
		 cell.setAttribute("onmouseout","modifyDOM(this)");
		 cell.setAttribute("onclick","modifyDOMfromTMX(this)");
         hrow.appendChild(cell);
		 cell.setAttribute("id","xliff");
        		 	
      tbody.appendChild(hrow);
	 
 }

 document.getElementById("tableDiv").appendChild(table);
 }
 
 
 function modifyDOMfromTMX(x){
 
// in xliff target col
 var cellIndex = x.cellIndex;
 var rowIndex = x.parentNode.rowIndex;
 // get the xliff source col text from the xmldoc 
 var transunits= xmlDoc.getElementsByTagName("trans-unit");
 tchild=transunits[rowIndex-1].children[0].innerHTML;
 // check if we have a tmxDoc
 if (tmxDoc !== undefined){
 var segments= tmxDoc.getElementsByTagName("seg");
 for (var i=0;i < segments.length; i=i+2){
   source=segments[i].innerHTML;	
   
   if (source===tchild) { 
      var r = confirm("Source: "+ source+"\nTarget: \n"+segments[i+1].innerHTML);
        if (r == true) {
           x.innerHTML= segments[i+1].innerHTML;  document.getElementById("lastCellEdit").innerHTML=rowIndex;
		   x.focus();
		   break;
         } else {
         return;
         } 
 }
 }
 }
 else {
 
 window.status="no tmx"; 
 return;
 }

  
// now update the targetnode in the xliff  
 var child = targetNodes[rowIndex-1];
 var old=child.innerHTML;
 try{
 if (old !== x.innerHTML ){
  child.innerHTML=x.innerHTML;
  document.getElementById("lastCellEdit").innerHTML=rowIndex;
 // alert(old + " ----> "  + x.innerHTML);
  }
 }
 catch(error) {
 alert("Copy the target segment with CTRL+C & CTRL+V to fix the empty segment");
 }
 
 }

 
 function modifyDOM(x){
 
 var cellIndex = x.cellIndex;
 var rowIndex = x.parentNode.rowIndex;
 
 var child = targetNodes[rowIndex-1];
 var old=child.innerHTML;
 try{
 if (old !== x.innerHTML ){
  child.innerHTML=x.innerHTML;
  //alert(old + " ----> "  + x.innerHTML);
  document.getElementById("lastCellEdit").innerHTML=rowIndex;
  }
 }
 catch(error) {
 alert("Copy the target segment with CTRL+C & CTRL+V to fix the empty segment");
 
 }
 
 }
 
 function storeXliff(){
 try{
  var xmlString = new XMLSerializer().serializeToString( xmlDoc );
  //localStorage.xliff=xliffContent;
  localStorage.xliff=xmlString;
  }catch(error){
  alert (error);
  }
 
 }

 function saveXliff(){
 var xmlString = new XMLSerializer().serializeToString( xmlDoc );
 
 var blob = new Blob([xmlString], { type: "text/xml"});
	 	var a = document.createElement('a');
  	    a.href = window.URL.createObjectURL(blob);
	    document.body.appendChild(a);
	    a.download = localStorage.xliffName;
        a.click();	
 
 }
 
 /* do as simple a parsing operation as possible
 assume a bilingual tmx and get only the <segs>  
 */
 function parseTMX(){

 var tbl=document.getElementById("tmxDiv");
 if (tbl !== null)
  tbl.innerHTML="";
  
 // localStorage.clear();
 
 parser = new DOMParser();
 tmxDoc = parser.parseFromString(tmxContent,"text/xml");
 //get all segments
 var segments= tmxDoc.getElementsByTagName("seg");
 alert("Total segments in the TMX: "+segments.length);
 var source; var target; var text="start";
 var tchildren;
 
            var table = document.createElement('table');
            table.innerHTML = "";
            var thead = document.createElement('thead');
            table.appendChild(thead);
            var hrow = document.createElement('tr');
            thead.appendChild(hrow);
            var tbody = document.createElement('tbody');
            table.appendChild(tbody);
			var cell;
            var cellText;
 
 for (var i=0;i < segments.length; i++ ){  
      var hrow = document.createElement('tr');	  
  	  
         cell = document.createElement('td');
         source=segments[i].innerHTML;		 
         cellText = document.createTextNode(source);
         cell.appendChild(cellText);
         hrow.appendChild(cell);	 
		 cell.setAttribute("id","xliff");
	     target=segments[++i].innerHTML; 
		
         cell = document.createElement('td');	 
		 
         cellText = document.createTextNode(target);
         cell.appendChild(cellText);
         hrow.appendChild(cell);
         cell.setAttribute("id","xliff");		 
      tbody.appendChild(hrow);
	 
 }

 document.getElementById("tmxDiv").appendChild(table);
 }
 
 
</script>

</head>
<body>
<div id="header">
<label for="fileinput">Load "xliff" or ".tmx" file:<input type="file" id="fileinput" multiple /></label>
<!--
<input type="button" id="btnParse" value="Import file into table" onclick="parseXliff()"/>
-->
<input type="button" id="btnStore" value="Store translation in Browser" onclick="storeXliff()"/>
<input type="button" id="btnSave" value="Export translation to file" onclick="saveXliff()"/>
<label for"lastCellEdit">Last target segment changed:<output id="lastCellEdit">None</output></label> 

</div>
<div id="bod">
<div id=tableDiv></div>
</div>
<p id="note"> Tmx will be read-only</p>
<div id="tmx">
<div id=tmxDiv></div>
</div>


</body>

</html>